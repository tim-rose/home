#!/bin/sh
# .BASHRC (->.KSHRC) --RC file for (interactive) Bourne-like shells.
#
# Contents:
# ps1_vcs()    --Show the current git branch, if any.
# cmd_status() --Print the status of the previous command, if it failed.
# set_prompt() -- Customise the user prompt.
#
# Remarks:
# All this script does is to set up a fairly elaborate, colourful
# shell prompt.  It does this with a few helper functions.
#
#date "+.bashrc: %c"
umask 002
set -o ignoreeof	# ignore <CTRL d>, use exit to terminate ksh
set -o emacs		# Set up in-line edit
HISTCONTROL=ignoreboth		# bash history control

if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

#
# ps1_vcs() --Show the current git branch, if any.
#
ps1_vcs()
{
    git branch 2>/dev/null | sed -ne '/^[*]/s/^[*] */:/p'
}

#
# cmd_status() --Print the status of the previous command, if it failed.
#
cmd_status()
{
    local status=$? reason= signal= signal_name=

    if [ $status -ge 128 ]; then
	signal=$(($status-128))
	if ! signal_name=$(kill -l $signal 2>/dev/null); then
	    signal_name="unknown signal"
	fi
	reason="caught signal $signal ($signal_name)"
    elif [ $status != 0 ]; then
	reason="exit status $status"
    fi
    if [ $status != 0 ]; then
	printf "\033[1;31m# command failed: %s.\033[m\n" "$reason"
    fi
}

#
# set_prompt() -- Customise the user prompt.
#
# Remarks:
# Set main prompt, to ": [<stuff>]; ". Note, this prompt is
# syntactally a shell nop, so complete lines can be selected and
# pasted for re-execution.
#
# Note: this function is removed after it is used.
#
# REVISIT: disable apple-term's "represented file" stuff?:
# \033]6;file-url\007 \033]7;file-url\007
#
set_prompt()
{
    local fg= bg= window_title= mode=
    if [ "$VCS" = "git" ]; then
	vcs_prompt="\$(ps1_vcs)"
    fi

    # local/remote customisation: local=green, remote=cyan
    if [ "$SSH_CONNECTION" ]; then fg=36; else fg=32; fi

    # privilege customisation: root=yellow/red
    case $(id) in *0?root?*) fg=33; bg=41;; *) bg=;; esac

    # finalise fg, bg "colours"
    if [ "$bg" ]; then
	mode="\e[${fg};${bg};1m"
    else
	mode="\e[${fg};1m"
    fi

    #
    # terminal customisation: if supported:
    #  * show additional info in title bar
    #  * show VCS status/info
    #  * adjust fg/bg as per above customisations
    #
    case "$TERM" in
	xterm*|rxvt*|dtterm*|cygwin)
	    PROMPT_COMMAND="cmd_status"
	    window_title='\[\e]1;\h\007\e]2;\u@\h \w\007\]'
            PS1="$window_title: [\[$mode\]\h$vcs_prompt\[\e[m\]]; "
            PS2="\[\e[36m\]: > \[\e[;m\]"
	    ;;
	ansi|linux|vt[0-9]*)	# colourful prompt only
	    PROMPT_COMMAND="cmd_status"
            PS1=": [\[$mode\]\h$vcs_prompt\[\e[m\]]; "
            PS2="\[\e[36m\]: > \[\e[;m\]"
	    ;;
	*)				# display hostname in prompt
	    PROMPT_COMMAND="cmd_status \$?"
            PS1=': [\h$vcs_prompt]; '
	    PS2=': > '
	    ;;
    esac

    if [ "$DESKTOP_SESSION" = "gnome-classic" ]; then
	printf '\033]12;red\007'	# gnome: set red cursor (erk!)
    fi
}
set_prompt
unset set_prompt

#
# load any further customisations from the etc directory, and bashrc-<host>
#
for file in $HOME/etc/sh/* $HOME/$ENV-$HOSTNAME; do
    if [ -e "$file" ]; then
	. $file
    fi
done
